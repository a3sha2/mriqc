#! /bin/bash
# This script is meant to evoke the algorithm without requiring any input arguments
#

# Define directory names and containers
FLYWHEEL_BASE=/flywheel/v0
INPUT_DIR=$FLYWHEEL_BASE/input/nifti
ROOTOUT_DIR=$FLYWHEEL_BASE/output
OUTPUT_DIR=$ROOTOUT_DIR/out
WORKING_DIR=$ROOTOUT_DIR/work
LOG_FILE=/flywheel/v0/output/mriqc.log

(
  CONTAINER='[flywheel/mriqc]'
  # Check if the input directory is not empty
  if [[ "$(ls -A $INPUT_DIR)" ]] ; then
      echo "$CONTAINER  Starting..."
  else
      echo "Input directory is empty: $INPUT_DIR"
      exit 1
  fi

  # Find input file in input directory with the extension .nii, .nii.gz
  input_file=`find $INPUT_DIR -iname '*.nii' -o -iname '*.nii.gz'`
  bni=`basename "$input_file"`
  filename="${bni%%.*}"
  inextension="${bni#*.}"

  # If input file found
  if [[ ! -e $input_file ]]; then
      echo "No Nifti files (.nii or .nii.gz) were found within input directory $INPUT_DIR"
      exit 1
  fi

  ## Check if the input filename is already BIDS compliant
  bids_func_re="sub-[0-9a-zA-Z]+_task-[0-9a-zA-Z]+(_acq-[0-9a-zA-Z]+)?(_rec-[0-9a-zA-Z]+)?(_run-[0-9]+)?_bold"
  if [[ $filename =~ $bids_func_re ]]; then
      # Since BIDS compliant -- extract the participant label number and description of the file
      #   participant label to be used in naming scheme as well as being passed to algorithm as a command line argument
      tmp="${filename#sub-*}"
      PARTICIPANT_LABEL="${tmp%%_*}"
     # Get the file description for BIDS format (Functional: task-<task_label>[_acq-<label>_rec-<label>_run<index>]_bold)
      filedesc="${tmp#$PARTICIPANT_LABEL}"
  # Otherwise, not BIDS compliant
  else
      # Pull out all letters and numbers from input filename to be used as participant label
      PARTICIPANT_LABEL="${filename//[!0-9a-zA-Z]}"
      # Make the file description the most basic form in BIDS format
      filedesc=_task-_bold
  fi

  ## Create a BIDS format directory to be ingested by MRIQC
  # Define top level dir
  BIDS_DIR=$WORKING_DIR/sub-$PARTICIPANT_LABEL
  # Define the sub directory (Functional: func)
  subdirname='func'
  # Define subdir and bids_file
  BIDS_SUBDIR=$BIDS_DIR/$subdirname
  bids_file=sub-$PARTICIPANT_LABEL$filedesc.$inextension
  mkdir -p $BIDS_SUBDIR
  # Change filename to be in BIDS format (may already be in BIDS format)
  cp $input_file $BIDS_SUBDIR/$bids_file

  # Call MRIQC software
  source /etc/fsl/fsl.sh
  source /etc/afni/afni.sh
  /usr/local/miniconda/bin/mriqc $BIDS_DIR $OUTPUT_DIR participant -w $WORKING_DIR --participant_label $PARTICIPANT_LABEL

  # Cleanup outputs
  # Define the expected output report filename generated by mriqc
  if [[ $filedesc == "_task-_bold" ]]; then
      outfilename=sub-$PARTICIPANT_LABEL'_bold.html'
  else
      outfilename=sub-$PARTICIPANT_LABEL$filedesc'.html'
  fi

  # Move html report to the output directory and rename to match the original input filename
  cp $OUTPUT_DIR/reports/$outfilename $ROOTOUT_DIR/$filename'_mriqc.qa.html'
  # Remove the working directory
  rm -r $WORKING_DIR
  rm -r $OUTPUT_DIR

  # Get a list of the files in the output directory
  outputs=`find $ROOTOUT_DIR -type f -name "*"`
  # If outputs exist, then go on...
  if [[ -z $outputs ]]
      then
          echo "No results found in output directory... Exiting"
          exit 1
      else
          chmod -R 777 $ROOTOUT_DIR
          echo -e "Wrote: `ls $ROOTOUT_DIR`"
  fi

  exit 0
) 2>&1 | tee $LOG_FILE
