#! /bin/bash
# This script is meant to evoke the algorithm without requiring any input arguments
#

# Define directory names and containers
FLYWHEEL_BASE=/flywheel/v0
MANIFEST_FILE=$FLYWHEEL_BASE/manifest.json
CONFIG_FILE=$FLYWHEEL_BASE/config.json
INPUT_DIR=$FLYWHEEL_BASE/input/nifti
ROOTOUT_DIR=$FLYWHEEL_BASE/output
OUTPUT_DIR=$ROOTOUT_DIR/out
WORKING_DIR=$ROOTOUT_DIR/work
CONTAINER='[flywheel/mriqc]'

# Configure the ENV according to the original Docker image
source ${FLYWHEEL_BASE}/docker-env.sh

# Check if the input directory is not empty
if [[ "$(ls -A $INPUT_DIR)" ]] ; then
    echo "$CONTAINER  Starting..."
else
    echo "Input directory is empty: $INPUT_DIR"
    exit 1
fi

# Find input file in input directory with the extension .nii, .nii.gz
input_file=`find $INPUT_DIR -iname '*.nii' -o -iname '*.nii.gz'`
bni=`basename "$input_file"`
filename="${bni%%.*}"
inextension="${bni#*.}"
# If input file not found, raise error
if [[ ! -e $input_file ]]; then
    echo "No Nifti files (.nii or .nii.gz) were found within input directory $INPUT_DIR"
    exit 1
fi

## Check if the input filename is already BIDS compliant
bids_func_re="sub-[0-9a-zA-Z]+_task-[0-9a-zA-Z]+(_acq-[0-9a-zA-Z]+)?(_rec-[0-9a-zA-Z]+)?(_run-[0-9]+)?_bold"
bids_anat_re="sub-[0-9a-zA-Z]+(_ses-[0-9a-zA-Z]+)?(_acq-[0-9a-zA-Z]+)?(_rec-[0-9a-zA-Z]+)?(_run-[0-9]+)?_[T1w|T2w]"
if [[ $filename =~ $bids_func_re ]]; then
    bids_compliant=true
    measurement="Functional"
elif [[ $filename =~ $bids_anat_re ]]; then
    bids_compliant=true
    measurement="Structural"
# Otherwise, not BIDS compliant -- need to determine measurement (Functional or Structural) from config file
else
    bids_compliant=false
    # Check config file for measurement
    if [[ -e $CONFIG_FILE ]]; then
        measurement=`cat $CONFIG_FILE | jq -r '.config.measurement'`
    # If no config file present, get default from manifest file
    else
        measurement=`cat $MANIFEST_FILE | jq -r '.config.measurement.default'`
    fi
fi
# Define BIDS subdirectory based on measurement type
if [[ $measurement = 'Functional' ]]; then
    subdirname='func'
else
    subdirname='anat'
fi

# Define BIDS features based on spec
if [[ $bids_compliant = 'true' ]]; then
    # Since BIDS compliant -- extract the participant label number and description of the file
    #   participant label to be used in naming scheme as well as being passed to algorithm as a command line argument
    tmp="${filename#sub-*}"
    PARTICIPANT_LABEL="${tmp%%_*}"
    # Get the file description for BIDS format (Functional: task-<task_label>[_acq-<label>_rec-<label>_run<index>]_bold)
    filedesc="${tmp#$PARTICIPANT_LABEL}"
else
    # Since NOT BIDS compliant-- extract all letters and numbers from input filename to be used as participant label
    PARTICIPANT_LABEL="${filename//[!0-9a-zA-Z]}"
    if [[ $measurement = 'Functional' ]]; then
        # Make the file description the most basic form in BIDS format for Functional images
        filedesc='_task-_bold'
    else
        # Make the file description T1w -- in general, structural
        filedesc='_T1w'
    fi
fi

## Create a BIDS format directory to be ingested by MRIQC
# Define top level dir
BIDS_DIR=$WORKING_DIR/sub-$PARTICIPANT_LABEL
# Define subdir and bids_file
BIDS_SUBDIR=$BIDS_DIR/$subdirname
bids_file=sub-$PARTICIPANT_LABEL$filedesc.$inextension
mkdir -p $BIDS_SUBDIR
# Change filename to be in BIDS format (may already be in BIDS format)
cp $input_file $BIDS_SUBDIR/$bids_file

# Call MRIQC software
source /etc/fsl/fsl.sh
source /etc/afni/afni.sh
/usr/local/miniconda/bin/mriqc $BIDS_DIR $OUTPUT_DIR participant -w $WORKING_DIR --participant_label $PARTICIPANT_LABEL

# Cleanup outputs
# Define the expected output report filename generated by mriqc - NOTE: strange case with Functional file desc
if [[ $filedesc == "_task-_bold" ]]; then
    outfilename=sub-$PARTICIPANT_LABEL'_bold.html'
else
    outfilename=sub-$PARTICIPANT_LABEL$filedesc'.html'
fi

# Move html report to the output directory and rename to match the original input filename
cp $OUTPUT_DIR/reports/$outfilename $ROOTOUT_DIR/$filename'_mriqc.qa.html'
# Remove the working directory
#rm -r $WORKING_DIR
#rm -r $OUTPUT_DIR

# Get a list of the files in the output directory
outputs=`find $ROOTOUT_DIR -type f -name "*"`
# If outputs exist, then go on...
if [[ -z $outputs ]]
    then
        echo "No results found in output directory... Exiting"
        exit 1
    else
        echo -e "{ \"acquisition\" : { \"files\" : [{ \"name\" : \""$filename'_mriqc.qa.html'"\", \"type\": \"qa\", \"measurements\": [\"Functional\"]}]}}" > $ROOTOUT_DIR/.metadata.json
        chmod -R 777 $ROOTOUT_DIR
        echo -e "Wrote: `ls $ROOTOUT_DIR`"
fi

exit 0
