#! /bin/bash
#
#
# @Authorship: Jennifer Reiter
# Flywheel 2017
#
#


################################################################################
# DEFINE VARIABLES

FLYWHEEL_BASE=/flywheel/v0
MANIFEST_FILE=$FLYWHEEL_BASE/manifest.json
CONFIG_FILE=$FLYWHEEL_BASE/config.json
INPUT_DIR=$FLYWHEEL_BASE/input/nifti
ROOTOUT_DIR=$FLYWHEEL_BASE/output
OUTPUT_DIR=$ROOTOUT_DIR/out
WORKING_DIR=$ROOTOUT_DIR/work
CONTAINER='[flywheel/mriqc]'


################################################################################
# CONFIGURE ENV

source ${FLYWHEEL_BASE}/docker-env.sh
source /etc/fsl/fsl.sh
source /etc/afni/afni.sh


################################################################################
# LOGGING

# exec > >(tee -i $FLYWHEEL/output/stdout.log) 2> >(tee -i $FLYWHEEL/output/stderr.log >&2)


################################################################################
# VALIDATE INPUT DATA

# Check if the input directory is not empty
if [[ "$(ls -A $INPUT_DIR)" ]] ; then
    echo "$CONTAINER  Starting..."
else
    echo "Input directory is empty: $INPUT_DIR"
    exit 1
fi

# Find input file in input directory with the extension .nii, .nii.gz
input_file=`find $INPUT_DIR -iname '*.nii' -o -iname '*.nii.gz'`
bni=`basename "$input_file"`
filename="${bni%%.*}"
inextension="${bni#*.}"

# If input file not found, raise error
if [[ ! -e $input_file ]]; then
    echo "No Nifti files (.nii or .nii.gz) were found within input directory $INPUT_DIR"
    exit 1
fi


################################################################################
## CHECK FOR BIDS COMPLIANCE

bids_func_re="sub-[0-9a-zA-Z]+(_ses-[0-9a-zA-Z]+)?_task-[0-9a-zA-Z]+(_acq-[0-9a-zA-Z]+)?(_rec-[0-9a-zA-Z]+)?(_run-[0-9]+)?(_echo-[0-9]+)?_bold"
bids_anat_re="sub-[0-9a-zA-Z]+(_ses-[0-9a-zA-Z]+)?(_acq-[0-9a-zA-Z]+)?(_ce-[0-9a-zA-Z]+)?(_rec-[0-9a-zA-Z]+)?(_run-[0-9]+)?(_mod-[0-9a-zA-Z]+)?_[T1w|T2w]"

if [[ $filename =~ $bids_func_re ]]; then
    bids_compliant=true
    measurement="functional"
    echo "Input filename is in BIDS format for a $measurement image"

elif [[ $filename =~ $bids_anat_re ]]; then
    bids_compliant=true
    # measurement is either anatomy_t1w or antomy_t2w
    # get end of file, if it's T1w or T2w
    # Transform T1w/T2w -> anatomy_t1w/anatomy_t2w
    desc="${filename:(-3)}"
    if [[ $desc = 'T1w' ]]; then
        measurement='anatomy_t1w'
    fi
    if [[ $desc = 'T2w' ]]; then
        measurement='anatomy_t2w'
    fi
    echo "Input filename is in BIDS format for an $measurement image"

else
    # Not BIDS compliant -- need to determine measurement (functional, anatomy_t1w, or anatomy_t2w) from config file
    bids_compliant=false
    echo "Input filename is not in BIDS format. Detecting measurement..."

    # Check config file for measurement
    if [[ -e $CONFIG_FILE ]]; then
        measurement=`cat $CONFIG_FILE | jq -r '.config.measurement'`
    # If no config file present, get default from manifest file
    else
        measurement=`cat $MANIFEST_FILE | jq -r '.config.measurement.default'`
    fi

    ## Determine measurement
    # Check if autodetect, otherwise use what was read in from config.json/manifest.json
    if [[ $measurement = 'auto-detect' ]]; then
        echo "Auto-detecting input file measurement"
        # Get measurement from context
        measurement=`cat $CONFIG_FILE | jq -r '.inputs.nifti.object.measurements[0]'`
        # Check if measurement that is read in is either anatomy_t1w, anatomy_t2w, or functional
        measurementArray=(functional anatomy_t1w anatomy_t2w)
        # Determine if measurement
        found=false
        for item in "${measurementArray[@]}"; do
            if [[ $measurement == $item ]]; then
                found=true
            fi
        done
        if $found; then
            echo "Auto-detected input file measurement as $measurement"
        else
            echo "Auto-detected measurement is $measurement"
            echo "Measurement needs to be 'anatomy_t1w', 'anatomy_t2w', or 'functional'"
            echo "MRIQC algorithm will not run - nothing to do - exit(0)"
            exit 0
        fi
    else
    # Not auto-detecting measurement - measurement what was given by user
        echo "File measurement indicated by user. Measurement is $measurement"
    fi
fi

################################################################################
# DEFINE BIDS LABELS

# Define BIDS subdirectory based on measurement type
if [[ "$measurement" = 'anatomy_t1w' ]]; then
    subdirname='anat'
elif [[ "$measurement" = 'anatomy_t2w' ]]; then
    subdirname='anat'
else
    subdirname='func'
fi

if [[ $bids_compliant = 'true' ]]; then
    # Since BIDS compliant -- extract the participant label number and description of the file
    #   participant label to be used in naming scheme as well as being passed to algorithm as a command line argument
    tmp="${filename#sub-*}"
    PARTICIPANT_LABEL="${tmp%%_*}"
    # Get the file description for BIDS format (functional: task-<task_label>[_acq-<label>_rec-<label>_run<index>]_bold)
    filedesc="${tmp#$PARTICIPANT_LABEL}"
else
    # Since NOT BIDS compliant-- extract all letters and numbers from input filename to be used as participant label
    PARTICIPANT_LABEL="${filename//[!0-9a-zA-Z]}"
    # Determine the file description at the end of the filename
    if [[ $measurement = "functional" ]]; then
        # Make the file description the most basic form in BIDS format for functional images
        filedesc='_task-_bold'
    else
        # The file description is T1w if measurement is 'anatomy_t1w'
        if [[ $measurement == "anatomy_t1w" ]]; then
            filedesc='_T1w'
        fi
        # The file description is T2w if measurement is 'anatomy_t2w'
        if [[ $measurement == "anatomy_t2w" ]]; then
            filedesc='_T2w'
        fi
    fi
fi


################################################################################
# CREATE A BIDS FORMATTED DIRECTORY

# Define top level dir
BIDS_DIR=$WORKING_DIR/sub-$PARTICIPANT_LABEL

# Define subdir and bids_file
BIDS_SUBDIR=$BIDS_DIR/$subdirname
bids_file=sub-$PARTICIPANT_LABEL$filedesc.$inextension
mkdir -p $BIDS_SUBDIR

# Change filename to be in BIDS format (may already be in BIDS format)
cp $input_file $BIDS_SUBDIR/$bids_file


################################################################################
# RUN MRIQC

/usr/local/miniconda/bin/mriqc $BIDS_DIR $OUTPUT_DIR participant -w $WORKING_DIR --participant_label $PARTICIPANT_LABEL

################################################################################
# CLEANUP OUTPUTS & GENERATE METADATA

# Define the expected output report filename generated by mriqc - NOTE: strange case with Functional file desc
if [[ $filedesc == "_task-_bold" ]]; then
    outfilename=sub-$PARTICIPANT_LABEL'_bold.html'
else
    outfilename=sub-$PARTICIPANT_LABEL$filedesc'.html'
fi

# Move html report to the output directory and rename to match the original input filename
cp $OUTPUT_DIR/reports/$outfilename $ROOTOUT_DIR/$filename'_mriqc.qa.html'

# Remove the working directory
rm -r $WORKING_DIR
rm -r $OUTPUT_DIR

# Get a list of the files in the output directory
outputs=`find $ROOTOUT_DIR -type f -name "*"`
# If outputs exist, then go on...
if [[ -z $outputs ]]
    then
        echo "No results found in output directory... Exiting"
        exit 1
    else
        # Metadata Creation
        echo -e "{ \"acquisition\" : { \"files\" : [{ \"name\" : \""$filename'_mriqc.qa.html'"\", \"type\": \"qa\", \"measurements\": [\""$measurement"\"]}]}}" > $ROOTOUT_DIR/.metadata.json
        chmod -R 777 $ROOTOUT_DIR
        echo -e "Wrote: `ls $ROOTOUT_DIR`"
fi

exit 0
